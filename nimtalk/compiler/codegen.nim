import std/[strutils, tables, sequtils]
import ../core/types
import ../parser/parser

# ============================================================================
# Nim Compiler for NimTalk
# Generates Nim code from Smalltalk methods
# ============================================================================

type
  CompilerContext* = ref object
    outputDir*: string
    moduleName*: string
    methods*: seq[BlockNode]
    symbols*: Table[string, string]  # selector -> symbol name

proc newCompiler*(outputDir = "./build", moduleName = "compiled"): CompilerContext =
  ## Create new compiler context
  result = CompilerContext(
    outputDir: outputDir,
    moduleName: moduleName,
    methods: @[],
    symbols: initTable[string, string]()
  )

# Generate symbol name from selector
proc mangleName(selector: string): string =
  ## Convert selector to valid Nim identifier
  # Replace special characters
  result = selector.replace(":", "_")
  result = result.replace("-", "_minus_")
  result = result.replace("+", "_plus_")
  result = result.replace("*", "_star_")
  result = result.replace("/", "_slash_")
  result = "nt_" & result

# Generate method stub
proc genMethodStub(method: BlockNode, selector: string): string =
  ## Generate Nim procedure stub for a Smalltalk method
  let nimName = mangleName(selector)
  let arity = method.parameters.len

  var result = "proc " & nimName & "*(self: ref ProtoObject"

  # Add parameters
  for param in method.parameters:
    result.add(", " & param & ": NodeValue")

  result.add("): NodeValue {.cdecl, exportc.} =\n")
  result.add("  ## Compiled method: " & selector & "\n")
  result.add("  ##\n")
  result.add("  discard\n")
  result.add("  return self.toValue()\n\n")

  return result

# Generate entire module
proc compileModule*(ctx: CompilerContext, methods: seq[BlockNode],
                   moduleName: string): string =
  ## Compile a set of methods to a Nim module
  if methods.len == 0:
    return ""

  var output = "## Generated by NimTalk Compiler\n"
  output.add("## Module: " & moduleName & "\n\n")
  output.add("import nimtalk/core/[types]\n")
  output.add("import nimtalk/interpreter/[objects, activation]\n\n")

  # Track methods
  ctx.methods = methods

  # Generate method stubs
  for method in methods:
    # Extract selector from method (for now, use a dummy)
    let selector = if method.parameters.len > 0:
                     "method" & $method.parameters.len
                   else:
                     "method"
    ctx.symbols[selector] = mangleName(selector)
    output.add(genMethodStub(method, selector))

  # Add module initialization
  output.add("proc init_" & moduleName & "*() =\n")
  output.add("  ## Initialize compiled module\n")
  output.add("  echo \"Module loaded: " & moduleName & "\"\n\n")

  return output

# Write module to file
proc writeModule*(ctx: CompilerContext, nimCode: string,
                 moduleName: string): string =
  ## Write compiled Nim code to file
  let filename = ctx.outputDir / moduleName & ".nim"
  createDir(ctx.outputDir)
  writeFile(filename, nimCode)
  return filename

# Simple compilation test
proc testCompilation*(): bool =
  ## Test basic compilation
  echo "Testing compilation..."

  try:
    let ctx = newCompiler()

    # Create a simple method
    let source = "[ :x | x ]"
    let tokens = lex(source)
    var parser = initParser(tokens)
    let method = parser.parseBlock()

    if method == nil:
      echo "Failed to parse block"
      return false

    method.isMethod = true
    method.parameters = @["x"]

    # Compile it
    let code = compileModule(ctx, @[method], "test")
    if code.len > 0:
      echo "Generated code length: " & $code.len
      discard writeModule(ctx, code, "test")
      echo "Compilation test passed"
      return true
    else:
      echo "No code generated"
      return false
  except Exception as e:
    echo "Compilation test failed: " & e.msg
    return false

when isMainModule:
  let ok = testCompilation()
  quit(if ok: 0 else: 1)
