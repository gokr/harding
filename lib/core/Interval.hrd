#!/usr/bin/env harding
#
# Interval.hrd - Numeric range for iteration
#

Interval := Object derive: #(intervalStart intervalStop intervalStep).

Interval class>>from: startInteger to: stopInteger [
    ^self from: startInteger to: stopInteger by: 1
]

Interval class>>from: startInteger to: stopInteger by: stepInteger [
    | interval |
    interval := self derive: #(intervalStart intervalStop intervalStep).
    interval intervalStart: startInteger.
    interval intervalStop: stopInteger.
    interval intervalStep: stepInteger.
    ^interval
]

Interval>>intervalStart [
    ^intervalStart
]

Interval>>intervalStart: anInteger [
    intervalStart := anInteger.
]

Interval>>intervalStop [
    ^intervalStop
]

Interval>>intervalStop: anInteger [
    intervalStop := anInteger.
]

Interval>>intervalStep [
    ^intervalStep
]

Interval>>intervalStep: anInteger [
    intervalStep := anInteger.
]

Interval>>start [
    ^intervalStart
]

Interval>>stop [
    ^intervalStop
]

Interval>>step [
    ^intervalStep
]

Interval>>size [
    # Number of elements in the interval
    intervalStep = 0 ifTrue: [ ^0 ].
    intervalStep > 0
        ifTrue: [
            intervalStart > intervalStop ifTrue: [ ^0 ].
            ^((intervalStop - intervalStart) // intervalStep) + 1
        ]
        ifFalse: [
            intervalStart < intervalStop ifTrue: [ ^0 ].
            ^((intervalStart - intervalStop) // (0 - intervalStep)) + 1
        ].
]

Interval>>isEmpty [
    ^self size = 0
]

Interval>>includes: aNumber [
    # Check if number is in the interval
    | remainder |
    intervalStep = 0 ifTrue: [ ^false ].
    intervalStep > 0
        ifTrue: [
            (aNumber < intervalStart or: [aNumber > intervalStop]) ifTrue: [ ^false ].
        ]
        ifFalse: [
            (aNumber > intervalStart or: [aNumber < intervalStop]) ifTrue: [ ^false ].
        ].
    remainder := (aNumber - intervalStart) \\ intervalStep.
    remainder = 0 ifTrue: [ ^true ].
    # Handle negative step
    remainder = intervalStep ifTrue: [ ^true ].
    ^false
]

Interval>>do: aBlock [
    # Iterate over each value in the interval
    | current |
    current := intervalStart.
    intervalStep > 0
        ifTrue: [
            [ current <= intervalStop ] whileTrue: [
                aBlock value: current.
                current := current + intervalStep.
            ].
        ]
        ifFalse: [
            [ current >= intervalStop ] whileTrue: [
                aBlock value: current.
                current := current + intervalStep.
            ].
        ].
    ^self
]

Interval>>collect: aBlock [
    # Transform each element, return Array
    | result |
    result := Array new.
    self do: [:each | result add: (aBlock value: each)].
    ^result
]

Interval>>select: aBlock [
    # Return Array with elements satisfying aBlock
    | result |
    result := Array new.
    self do: [:each | (aBlock value: each) ifTrue: [ result add: each ]].
    ^result
]

Interval>>reject: aBlock [
    # Return Array with elements not satisfying aBlock
    ^self select: [:each | (aBlock value: each) not]
]

Interval>>detect: aBlock [
    # Find first element satisfying aBlock
    self do: [:each | (aBlock value: each) ifTrue: [ ^each ]].
    ^nil
]

Interval>>detect: aBlock ifNone: noneBlock [
    # Find first element satisfying aBlock, or evaluate noneBlock
    self do: [:each | (aBlock value: each) ifTrue: [ ^each ]].
    ^noneBlock value
]

Interval>>inject: initialValue into: aBlock [
    # Accumulate result
    | result |
    result := initialValue.
    self do: [:each | result := aBlock value: result value: each].
    ^result
]

Interval>>anySatisfy: aBlock [
    # Return true if any element satisfies aBlock
    self do: [:each | (aBlock value: each) ifTrue: [ ^true ]].
    ^false
]

Interval>>allSatisfy: aBlock [
    # Return true if all elements satisfy aBlock
    self do: [:each | (aBlock value: each) ifFalse: [ ^false ]].
    ^true
]

Interval>>sum [
    # Sum of all elements
    | total |
    total := 0.
    self do: [:each | total := total + each].
    ^total
]

Interval>>max [
    # Maximum value (largest by magnitude respecting step direction)
    intervalStep >= 0 ifTrue: [ ^intervalStop ].
    ^intervalStart
]

Interval>>min [
    # Minimum value (smallest by magnitude respecting step direction)
    intervalStep >= 0 ifTrue: [ ^intervalStart ].
    ^intervalStop
]

Interval>>asArray [
    # Convert to Array
    | result |
    result := Array new: self size.
    self withIndexDo: [:each :index | result at: index put: each].
    ^result
]

Interval>>withIndexDo: aBlock [
    # Iterate with 1-based index
    | index current |
    index := 1.
    current := intervalStart.
    intervalStep > 0
        ifTrue: [
            [ current <= intervalStop ] whileTrue: [
                aBlock value: current value: index.
                current := current + intervalStep.
                index := index + 1.
            ].
        ]
        ifFalse: [
            [ current >= intervalStop ] whileTrue: [
                aBlock value: current value: index.
                current := current + intervalStep.
                index := index + 1.
            ].
        ].
    ^self
]

Interval>>reversed [
    # Return new Interval going in opposite direction
    ^Interval from: intervalStop to: intervalStart by: (0 - intervalStep)
]

Interval>>printString [
    # String representation: (1 to: 10 by: 2)
    ^"(" , (intervalStart printString) , " to: " , (intervalStop printString) , " by: " , (intervalStep printString) , ")"
]

Interval>>= anInterval [
    # Equality check
    (anInterval isKindOf: Interval) ifFalse: [ ^false ].
    ^(intervalStart = anInterval intervalStart) and: [
        (intervalStop = anInterval intervalStop) and: [
            intervalStep = anInterval intervalStep
        ]
    ]
]

# Add to: and to:by: methods to Number for convenience

Number>>to: stopNumber [
    ^Interval from: self to: stopNumber
]

Number>>to: stopNumber by: stepNumber [
    ^Interval from: self to: stopNumber by: stepNumber
]

# Make Interval compatible with collection methods

Interval>>first [
    ^intervalStart
]

Interval>>last [
    intervalStep > 0 ifTrue: [
        ^intervalStop - ((intervalStop - intervalStart) \\ intervalStep)
    ].
    ^intervalStop + ((intervalStart - intervalStop) \\ (0 - intervalStep))
]
